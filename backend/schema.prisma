// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS ---

enum UserRole {
  Admin
  Monitor
  Viewer
}

enum UserStatus {
  Active
  Suspended
  Invited
}

// Status for background job execution
enum RunStatus {
  QUEUED
  RUNNING
  SUCCESS
  FAILED
  CANCELLED
}

// --- CORE MODELS ---

model User {
  id             String      @id @default(uuid())
  email          String      @unique
  name           String
  role           UserRole    @default(Viewer)
  status         UserStatus  @default(Active)
  passwordHash   String?     // Nullable for invited users
  lastActive     DateTime    @default(now())
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  // Settings stored as JSON to match UserSettings interface (theme, notifs, etc)
  settings       Json?       
  
  // Relations
  posts          Post[]
  accounts       IntegrationAccount[]
  mediaItems     MediaItem[]
}

model IntegrationAccount {
  id             String   @id @default(uuid())
  userId         String
  platform       String   // "Twitter", "LinkedIn", etc.
  handle         String?
  accessToken    String?  // Encrypt this in production
  refreshToken   String?
  isConnected    Boolean  @default(false)
  lastSync       DateTime?
  
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, platform])
}

model Post {
  id             String   @id @default(uuid())
  title          String?  // For YouTube/Blog titles
  content        String
  description    String?  // Internal notes or meta description
  
  // Arrays are supported natively in Postgres
  platforms      String[] 
  
  status         String   // "Draft", "Scheduled", "Needs Review" (String used to support spaces)
  scheduledFor   DateTime
  
  // Media
  mediaUrl       String?
  mediaType      String?  // "image" | "video"
  thumbnailUrl   String?
  isCarousel     Boolean  @default(false)

  // AI & Context
  generatedByAi  Boolean  @default(false)
  author         String?  // "User" or "Creator Bot" (Loose relation to allow bot names)
  creationContext Json?   // { source: "AI", topic: "..." }
  
  // Advanced Config (JSON maps to interface types)
  variants       Json?    // Array of PostVariant
  activeVariantId String?
  autoOps        Json?    // { autoEngage: boolean }
  safetySettings Json?    // { bypassSafety: boolean }
  timezone       String?
  
  // Analytics Data
  engagement     Json?    // { likes: 0, shares: 0 }

  // Relations
  userId         String?
  user           User?    @relation(fields: [userId], references: [id])
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model MediaItem {
  id          String   @id @default(uuid())
  name        String
  type        String   // "image" | "video"
  url         String
  size        Int
  dimensions  String?
  createdAt   DateTime @default(now())
  
  userId      String?
  user        User?    @relation(fields: [userId], references: [id])
}

// --- AUTOMATION / BOTS ---

model BotConfig {
  id                String   @id @default(uuid())
  type              String   @unique // "Creator Bot", "Engagement Bot", etc.
  enabled           Boolean  @default(false)
  status            String   // "Idle", "Running", "Error"
  intervalMinutes   Int      @default(60)
  lastRun           DateTime?
  consecutiveFailures Int    @default(0)
  isPaused          Boolean  @default(false)

  // Configuration BLOBS
  config            Json     // BotSpecificConfig (rules, tags, safety)
  stats             Json     // { currentDailyActions: 0, maxDailyActions: 50 }
  
  // Logs (Legacy array support if needed, but we prefer relations)
  logs              Json?    // Storing simple log array for quick access if needed

  // Relations
  activities        BotActivity[]
  runs              BotRun[]
}

// Granular Activity Log (Used by BotEngine.ts service)
model BotActivity {
  id          String   @id @default(uuid())
  botType     String
  runId       String?  // Grouping ID for a specific execution cycle
  actionType  String   // "POST", "LIKE", "ANALYZE"
  platform    String
  status      String   // "SUCCESS", "FAILED", "SKIPPED"
  message     String
  error       String?
  metadata    Json?
  
  createdAt   DateTime @default(now())
  finishedAt  DateTime?

  bot         BotConfig @relation(fields: [botType], references: [type])
}

// High-Level Execution Session (Used by Worker executors)
model BotRun {
  id          String    @id @default(uuid())
  botType     String
  botId       String    // Could be "system" or specific instance
  status      RunStatus @default(RUNNING)
  createdAt   DateTime  @default(now())
  finishedAt  DateTime?
  error       String?

  bot         BotConfig @relation(fields: [botType], references: [type])
}

// --- INFRASTRUCTURE ---

// Custom Queue Table for Simulation Mode (See backend/src/lib/queue.ts)
model JobQueue {
  id            String   @id @default(uuid())
  queueName     String
  status        String   // "DELAYED", "PROCESSING", "COMPLETED"
  scheduledFor  DateTime
  payload       Json
  postId        String?  // Optional reference for traceability
  
  createdAt     DateTime @default(now())
  processedAt   DateTime?
}
